# useMemo

- useCallback과 함께 컴포넌트 최적화에 사용된다 



## 함수형 컴포넌트 

### 특징

- 함수로 되어있는 컴포넌트이다
- 화면을 렌더링 한다면 컴포넌트 함수를 호출하고 함수 모든 내부 변수를 초기화 하게된다
- 어떠한 함수에서 연산한 값을 컴포넌트 함수에서 사용한다고 할 때 컴포넌트 함수가 호출되면 될 때마다 변수가 초기화 되어 연산을 매번 해주어야 한다
  - 만약 같은 연산을 하고 같은 결과가 나오는 연산을 한다고 할 때는 비효율이 발생하게 된다



## useMemo의 활용

- 함수형 컴포넌트에서 변수의 값이 호출 될 때 마다 초기화 된다는 단점을 보완할 수 있다

  - 함수형 컴포넌트에서 어떠한 값을 사용한다고 할때 그 값을 저장해 두고 그 값을 계속 사용하다가 그값이 변한다면 다시 값을 받아 저장한다
  - 값이 변하지 않았다면 저장된 값을 그대로 사용하게 되며 해당 컴포넌트는 렌더링이 일어나지 않는다

- 어떠한 컴포넌트에 연산을 많이 사용하는 함수와 적게사용하는 함수가 있다

  - 이때 연산을 적게 사용하는 함수를 호출하여 state가 변하고 렌터링이 일어났다고 한다면
  - 컴포넌트 함수 자체를 호출하는 것이기 때문에 컴포넌트 안에 연산을 많이 사용하는 함수 또한 호출이 되고
  - 연산이 적은 함수를 사용 함에도 연산이 많은 함수까지 사용을 하게 된다 
  - 여기서 useMemo를 사용하여 많은 연산을 사용하는 함수는 그 함수의 값이 바뀔 때만 연산을 하고 
  - 바뀌지 않았을 때는 전에 연산해둔 값을 저장해두고 그값을 계속 사용하여 추가적인 연산을 막는다 

- 메모리를 사용하여 값을 저장하기 때문에 무분별한 사용은 오히려 성능을 낮출 수 있다

  

### useRef와의 차이점

-  어떠한 값을 받아 저장하며 렌더링이 일어나도 값이 초기화 되지않는 점이 비슷함
- 하지만 useRef는 저장되는 값이 바뀌더라도 렌더링에는 관여하지 않는다
- 반면 useMomo는 원하는 값의 변경이 일어난다면 소속되어있는 컴포넌트가 렌더일에 반응하게 함 



### JS의 원시타입과 객체 타입

- 원시타입(Primitive)
  - 종류
    - String
    - Number
    - Boolean
    - Null
    - Undefined
    - BigInt
    - Symbol
  - 특징
    - 변수에 바로 원시타입의 값이 저장됨
    - 같은 원시값을 가진 두가지 변수를 비교하면 true가 나온다 
      - 변수 안에 내용 자체를 비교 
- 객체 타입(object)
  - 종류
    - Object
    - Array
    - 원시타입을 제외한 모든 것
  - 특징
    - 객체는 값이 크기때문에 변수에 메모리의 주소가 저장되고, 별도의 메모리에 객체타입 값이 저장 된다
    - 같은 객체값을 가진 두가지 변수를 비교하면 false가 나온다
      - 변수 안에 객체값이 저장된 메모리 주소를 비교 
      - 변수1과 변수2가 사용하는 메모리 주소가 다름 
    - **함수에서 객체 변수를 받을 때는 함수가 호출 될 때마다 새로운 메모리 주소로 객체값을 할당 해주게 된다** 
      - 즉 useEffect에 객체를 받는 변수를 의존성 배열에 넣어준다면 
      - 렌더링 될 때마다 객체의 값을 저장하는 메모리 주소를 재할당 해주기 때문에 
      - useEffect 콜백함수 또한 호출되게 된다 

=> 변수에 저장하는 객체값의 주소를 저장해 두었다가 객체값의 내용이 바뀌었을 때만 재할당 해줄 필요가 있음 

=> useMemo를 활용하여 원하는 값이 바뀌었을 때만 렌더링에 반응하게 하여 객체값에 주소가 계속 바뀌지 않게 막아줄 수 있다 



## useMemo 사용법

```react
const value = useMemo(() => {
  return calculate();
}, [item]);
```

- 인자로 콜백함수와 배열을 받아준다
- 콜백함수
  - 메모리제이션 해줄 값을 계산해서 리턴해준다 
- 배열
  - 의존성 배열이라고도 불림 
  - 배열안 요소의 값이 업데이트 될 때만 콜백함수를 불러와서 다시 메모리제이션을 해준다 
  - 빈배열일 경우에는 맨처음 마운트 되었을 때만 메모리제이션을 해준다 

  

